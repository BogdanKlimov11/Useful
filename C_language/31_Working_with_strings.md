### Работа со строками в С ###

Строка — это последовательность ASCII или UNICODE символов.

**Строки в C**, как и в большинстве языков программирования высокого уровня рассматриваются как отдельный тип, 
входящий в систему базовых типов языка. Так как язык C по своему происхождению является языком системного 
программирования, то **строковый тип данных в C как таковой отсутствует, а в качестве строк в С используются 
обычные массивы символов**.

Исторически сложилось два представления формата строк:

1. формат ANSI;
2. cтроки с завершающим нулем (используется в C).

Формат ANSI устанавливает, что значением первой позиции в строке является ее длина, а затем следуют сами символы 
строки. Например, представление строки "Моя строка!" будет следующим:
```c
11 'М' 'о' 'я' ' ' 'с' 'т' 'р' 'о' 'к' 'а' '!'
```
В строках с завершающим нулем, значащие символы строки указываются с первой позиции, а признаком завершения строки 
является значение ноль. Представление рассмотренной ранее строки в этом формате имеет вид:
```c
'М' 'о' 'я' ' ' 'с' 'т' 'р' 'о' 'к' 'а' '!' 0
```
#### Объявление строк в C ####

Строки реализуются посредством массивов символов. Поэтому объявление ASCII строки имеет следующий синтаксис:
```c
char имя[длина];
```
Объявление **строки в С** имеет тот же синтаксис, что и объявление одномерного символьного массива. Длина строки должна 
представлять собой целочисленное значение (в стандарте C89 – константа, в стандарте C99 может быть выражением). 
Длина строки указывается с учетом одного символа на хранение завершающего нуля, поэтому максимальное количество 
значащих символов в строке на единицу меньше ее длины. Например, строка может содержать максимально двадцать символов, 
если объявлена следующим образом:
char str[21]; Инициализация строки в С осуществляется при ее объявлении, используя следующий синтаксис:
char str[длина] = строковый литерал;

Строковый литерал – строка ASCII символов заключенных в двойные кавычки. Примеры объявления строк с инициализацией:
```c
char str1[20] = "Введите значение: ", str2[20] = "";
```
Пример:
```c
const char message[] = "Сообщение об ошибке!";
```
#### Работа со строками в С ####

Так как строки на языке С являются массивами символов, то к любому символу строки можно обратиться по его индексу. 
Для этого используется синтаксис обращения к элементу массива, поэтому первый символ в строке имеет индекс ноль. 
Например, в следующем фрагменте программы в строке str осуществляется замена всех символов 'a' на символы 'A' и 
наоборот.
```c
for(int i = 0; str[i] != 0; i++)
{
    if (str[i] == 'a') str[i] = 'A';
    else if (str[i] == 'A') str[i] = 'a';
}
```
#### Массивы строк в С ####

Объявление массивов строк в языке С также возможно. Для этого используются двумерные массивы символов, что имеет 
следующий синтаксис:
```c
char имя[количество][длина];
```
Первым размером матрицы указывается количество строк в массиве, а вторым – максимальная (с учетом завершающего нуля) 
длина каждой строки. Например, объявление массива из пяти строк максимальной длиной 30 значащих символов будет иметь 
вид:
```c
char strs[5][31];
```
При объявлении массивов строк можно производить инициализацию:
```c
char имя[количество][длина] = {строковый литерал №1, … строковый литерал №N};
```
Число строковых литералов должно быть меньше или равно количеству строк в массиве. Если число строковых литералов меньше 
размера массива, то все остальные элементы инициализируются пустыми строками. Длина каждого строкового литерала должна 
быть строго меньше значения длины строки (для записи завершающего нуля).

Например:
```c
char days[12][10] = {
    "Январь", "Февраль", "Март", ”Апрель", "Май",
    "Июнь", "Июль", "Август", "Сентябрь","Октябрь",
    "Ноябрь", "Декабрь"
};
```
При объявлении массивов строк с инициализацией допускается не указывать количество строк в квадратных скобках. В таком 
случае, количество строк в массиве будет определено автоматически по числу инициализирующих строковых литералов.
Например, массив из семи строк:
```c
char days[][12] = {
    "Понедельник", "Вторник", "Среда", "Четверг",
    "Пятница", "Суббота", "Воскресенье"
};
```
#### Функции для работы со строками в С ####

Все библиотечные функции, предназначенные для работы со строками, можно разделить на три группы:

1. ввод и вывод строк;
2. преобразование строк;
3. обработка строк.

#### Ввод и вывод строк в С ####

Для ввода и вывода строковой информации можно использовать функции форматированного ввода и вывода (printf и scanf). 
Для этого в строке формата при вводе или выводе строковой переменной необходимо указать спецификатор типа %s. Например, 
ввод и последующий вывод строковой переменной будет иметь вид:
```c
char str[31] = "";
printf("Введите строку: ");
scanf("%30s”,str);
printf("Вы ввели: %s”,str);
```
Недостатком функции scanf при вводе строковых данных является то, что символами разделителями данной функции являются:

1. перевод строки,
2. табуляция;
3. пробел.

Поэтому, используя данную функцию невозможно ввести строку, содержащую несколько слов, разделенных пробелами или табуляциями. 
Например, если в предыдущей программе пользователь введет строку: "Сообщение из нескольких слов", то на экране будет выведено 
только "Сообщение".
Для ввода и вывода строк в библиотеке stdio.h содержатся специализированные функции gets и puts.

Функция gets предназначена для ввода строк и имеет следующий заголовок:
```c
char * gets(char *buffer);
```
Между тем использовать функцию `gets` категорически не рекомендуется, ввиду того, что она не контролирует выход за границу 
строки, что может произвести к ошибкам. Вместо нее используется функция fgets с тремя параметрами:
```c
char * fgets(char * buffer, int size, FILE * stream);
```
где buffer - строка для записи результата, size - максимальное количество байт, которое запишет функция fgets, stream - файловый 
объект для чтения данных, для чтения с клавиатуры нужно указать stdin. Эта функция читает символы со стандартного ввода, пока не 
считает n - 1 символ или символ конца строки, потом запишет считанные символы в строку и добавит нулевой символ. При этом функция 
fgets записывает в том символ конца строки в данную строку, что нужно учитывать.

Функция puts предназначена для вывода строк и имеет следующий заголовок:
```c
int puts(const char *string);
```
Простейшая программа: ввод и вывод строки с использованием функций fgets и puts будет иметь вид:
```c
char str[102] = "";
 printf("Введите строку: ");
fgets(str, 102, stdin);
 printf("Вы ввели: "); 
 puts(str);
```
Для считывания одного символа можно использовать функцию `fgetc(FILE * stream)`. Она считывает один символ и возвращает значение 
этого символа, преобразованное к типу int, если же считывание не удалось, то возвращается специальная константа EOF, равная -1. 
Функция возвращает значение -1 для того, чтобы можно было обрабатывать ситуацию конца файла, посимвольное чтение до конца файла 
можно реализовать следующим образом:
```c
int c;
while ((c = fgetc(stdin)) != EOF) {
    // Обработка символа
}
```
Для вывода одного символа можно использовать функцию  `int fputc(int c, FILE *stream);`.

Помимо функций ввода и вывода в потоки в библиотеке stdio.h присутствуют функции форматированного ввода и вывода в строки. Функция 
форматированного ввода из строки имеет следующий заголовок:
```c
int sscanf(const char * restrict buffer, const char * restrict string, [address] …);
```
Функции форматированного вывода в строку имеют следующие заголовки:
```c
int sprintf(char * restrict buffer,
 const char * restrict format, [argument] …);
 int snprintf(char * restrict buffer, size_t maxsize,
 const char * restrict format, [argument] …);
```
#### Преобразование строк ####

В С для преобразования строк, содержащих числа, в численные значения в библиотеке stdlib.h
предусмотрен следующий набор функций:<br>
`double atof(const char *string);` // преобразование строки в число типа double<br>
`int atoi(const char *string);` // преобразование строки в число типа int<br>
`long int atol(const char *string);` // преобразование строки в число типа long int<br>
`long long int atoll(const char *string);` // преобразование строки в число типа long long int<br>

Корректное представление вещественного числа в текстовой строке должно удовлетворять формату:

[ ][{+|-}][цифры][.цифры][{e|E}[{+|-}]цифры]

После символов E, e указывается порядок числа. Корректное представление целого числа в текстовой строке должно удовлетворять формату:

[ ] [{+|-}] цифры

Помимо приведенных выше функций в библиотеке stdlib.h доступны также следующие функции преобразования строк в вещественные числа:
```c
float strtof(const char * restrict string, char ** restrict endptr);
double strtod(const char * restrict string, char ** restrict endptr);
long double strtold(const char * restrict string,char ** restrict endptr);
```
Аналогичные функции присутствуют и для преобразования строк в целочисленные значения:
```c
long int strtol(const char * restrict string, char ** restrict endptr, int base);
unsigned long strtoul(const char * restrict string,
char ** restrict endptr, int base);
long long int strtoll(const char * restrict string,
char ** restrict endptr, int base);
unsigned long long strtoull(const char * restrict string,char ** restrict endptr, int base);
```
Функции обратного преобразования (численные значения в строки) в библиотеке stdlib.h присутствуют, но они не регламентированы 
стандартом, и рассматриваться не будут. Для преобразования численных значений в строковые наиболее удобно использовать функции 
sprintf и snprintf.

#### Обработка строк ####
В библиотеке string.h содержаться функции для различных действий над строками.
Функция вычисления длины строки:
```c
size_t strlen(const char *string);
```
Пример:
```c
char str[] = "1234";
int n = strlen(str); //n == 4
```
Функции копирования строк:
```c
char * strcpy(char * restrict dst, const char * restrict src);
char * strncpy(char * restrict dst, const char * restrict src, size_t num);
```
Функции сравнения строк:
```c
int strcmp(const char *string1, const char *string2);
int strncmp(const char *string1, const char *string2,size_t num);
```
Функции осуществляют сравнение строк по алфавиту и возвращают:

  положительное значение – если string1 больше string2;<br>
  отрицательное значение – если string1 меньше string2;<br>
  нулевое значение – если string1 совпадает с string2;<br>

Функции объединения (конкатенации) строк:
```c
char * strcat(char * restrict dst, const char * restrict src);
char * strncat(char * restrict dst, const char * restrict src, size_t num);
```
Функции поиска символа в строке:
```c
char * strchr(const char *string, int c);
char * strrchr(const char *string, int c);
```
Функция поиска строки в строке:
```c
char * strstr(const char *str, const char *substr);
```
Пример:
```c
char str[] = "Строка для поиска";
char *str1 = strstr(str,"для"); //str1 == "для поиска"
```
Функция поиска первого символа в строке из заданного набора символов:
```c
size_t strcspn(const char *str, const char *charset);
```
Функции поиска первого символа в строке не принадлежащему заданному набору символов:
```c
size_t strspn(const char *str, const char *charset);
```
Функции поиска первого символа в строке из заданного набора символов:
```c
char * strpbrk(const char *str, const char *charset);
```
Функция поиска следующего литерала в строке:
```c
char * strtok(char * restrict string, const char * restrict charset);
```
