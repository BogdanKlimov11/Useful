### Внешние переменные ###

#### Межмодульное взаимодействие ####

Файл как единица трансляции не должен содержать более одного определения любой переменной, функции, структуры, 
перечисления. One-Definition Rule — требование стандарта языка.

Для переменной компилятор по ее определению вычисляет размер и резервирует место в памяти, поэтому при наличии 
более одного определения в одной области видимости у него «возникают проблемы».

Для функции компилятор генерирует код, который в конечном счете тоже займет свое место в памяти.

А вот прототипов функций (объявлений) может быть несколько. Объявление лишь добавляет некоторое имя в данную 
область видимости и обычно используется для согласования типов. При разделении программы на отдельные модули 
возникают вопросы о взаимодействии определений и объявлений, прописанных в разных модулях.

#### Межмодульные переменные ####

Допустим, у нас есть два модуля **A.c** и **B.c**. В модуле **A** вне всех функций определена целая переменная:
```c
int i = 2;
```
Такая переменная называется глобальной. В файле **A** она видна от точки определения и до конца файла. Однако в модуле 
**B** эта переменная не видна. И если вдруг нам потребуется в модуле **B** присвоить ей другое значение, у нас возникнут 
некоторые проблемы. Нельзя просто написать:
```c
i = 1;
```
В этом случае компилятор при обработке модуля **B** «не видит» модуль **A** и ничего не знает об определенной там переменной, 
поэтому мы получим сообщение о неопределенной переменной. Также нельзя написать:
```c
int i = 1;
```
Такая запись является повторным определением. Компилятор-то «возражать» не станет — он транслирует модули по отдельности, 
а вот компоновщик на этапе сборки будет выдавать ошибку, что одна и та же переменная определена дважды. Для таких случаев 
в С++ включено специальное ключевое слово `extern`. В модуле **B** надо объявить переменную следующим образом:
```c
extern int i;
```
После этого можно использовать переменную `i` в файле **B** любым разрешенным способом. Например, присвоить новое значение:
```c
i = 1;
```
Однако попытка совместить объявление с присвоением значения является ошибкой:
```c
extern int i = 1;
```
Такая запись служит определением, поэтому мы опять получим от компоновщика сообщение о повторном определении.

*Имя называется внешним по отношению к модулю, если объект с этим именем не определен в данном модуле.*

#### Межмодульные переменные ####

Константы по умолчанию также компонуются внутренним образом. Это означает, что в разных модулях можно объявлять глобальные 
константы с одинаковыми именами — конфликта при компоновке не происходит.

Чтобы сделать константу, объявленную в одном модуле, видимой в другом, нужно, как и с переменными, использовать слово `extern`:
```c
// модуль A.c
extern const int a = 2;
```
```c
// модуль B.c
extern const int a;
```

#### Автоматическое подключение внешних переменных ####

Для того, чтобы **B.c** при включении заголовочного файла автоматически подключал необходимую внешнюю переменную, строчки с 
`extern` обычно вставляют в заголовочный файл A.h.
```c
// заголовочный файл A.h
extern const int a;
```
```c
// модуль B.cpp
#include "A.h"
```
