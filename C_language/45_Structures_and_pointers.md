### Структуры и указатели в С ###

В отличие от массивов, структуры передаются в функции по значению. Это не всегда рационально, т.к. структуры могут 
быть достаточно большого размера, копирование таких участков памяти может замедлять работу программы.

Поэтому даже если структуру не собираются изменять внутри функции, **принято передавать лишь адрес структуры и работать 
со структурой по указателю**.
```c
struct tStudent student; // переменная-структура
struct tStudent *p_student; // указатель на структуру
dismissStudent(&new); // передаем адрес
pnew = &new;
dismissStudent(pnew); // передаем указатель
```
Тогда функция **dismissStudent()** должна иметь примерно такое объявление:
```c
void dismissStudent(struct tStudent *pb)
```
При этом, если функция не собирается менять структуру, можно успокоить вызывающую сторону, упомянув в заголовке **const**:
```c
void dismissStudent(const struct tStudent *pb)
```

#### Обращение к полям структуры по указателю ####

Как при использовании указателя обратиться к полям структуры, если есть указатель на нее?

Во-первых надо получить сам экземпляр структуры разыменовав ее указатель: __*pb__.

Далее можно обращаться к полям через точку: __*pb.title__, но это выражение не верно, так как приоритет операции "точка" 
(обращение к полю) выше операции "звездочка" (получить значение по адресу). Таким образом, мы попытались сначала получить 
значение поля title у указателя **pb**, но у **pb** нет такого поля (он вообще не структура).

Проблема решается с помощью скобок, которые изменяют порядок выполнения операций:
```c
(*pb).title
```
Запись в такой форме достаточно громоздка, поэтому в Си добавлен синтаксический сахар:
```c
pb->title
```
Стрелка состоит из тире и знака больше (угловая правая скобка).

Запомните: pb->title $\equiv$ (*pb).title
