### Модульное программирование в C++ ###

**Раздельная компиляция** — общий принцип модульного программирования, работающий и в Си, и в С++.

* #define стражи в заголовочных файлах нужны для того, чтобы заголовочный файл нельзя было подключить 
дважды.
* namespace — пространство имен, позволяющее избежать конфликтов идентификаторов. Можно сделать несколько 
namespace в одном файле. Можно сделать один namespace в нескольких файлах. Пространство имен объединяет 
функции и статические переменные.
* using — инструкция, позволяющая в желаемом контексте (в рамках функции или ее части) работать с именами 
из данного пространства имен без указания каждый раз его имени.

*Пространство имён* определяется блоком инструкций:
```c++
namespace foo {
  int bar;
}
```
Внутри этого блока идентификаторы могут вызываться именно так, как они были объявлены. Но вне блока требуется 
указание имени пространства имён перед идентификатором. Например, вне namespace foo идентификатор bar должен 
указываться как foo::bar. C++ содержит некоторые другие конструкции, делающие подобные требования необязательными. 
Так, при добавлении строки
```c++
using namespace foo;
```
в код, указывать префикс foo:: больше не требуется. Ещё пример:
```c++
namespace Namespace12
{
  int foo=0;
}
```
```c++
void func1()
{
  using namespace Namespace12;
  // теперь все имена из пространства имён Namespace12 будут видны здесь без дополнительных префиксов
  ++foo;
}
```
```c++
void func2()
{
  // а тут имя нужно уточнить:
  Namespace12::foo = 42;
}
```
Разрешение пространств имён в C++ *иерархично*. Это означает, что в гипотетическом пространстве имён еда::суп, 
идентификатор курица будет обозначать еда::суп::курица (если пространство существует). Если не существует, то 
тогда он указывает на еда::курица (если это пространство существует). Если и это пространство не существует, 
то курица ссылается на идентификатор в глобальном пространстве.

Зачастую пространства имён в C++ используются для избежания коллизий имён.
