### Пространства имен в С++ ###

Пространство имён является механизмом отражения логического группирования идентификаторов. Если некоторые объявления 
можно объединить по какому-либо критерию, это можно отразить явным размещением их в одном пространстве имён.

Например, у нас есть несколько типов зверей, которые могут жить в зоопарке:
```c++
namespace Zoo{
    struct Dog{};
    struct Wolf{};
    struct Crocodile{};
}
```
Теперь обращаться к этим животным надо так: `Zoo::Dog`, `Zoo::Wolf` и `Zoo::Crocodile` — с использованием 
квалификатора `Zoo`.

Если это кажется сложным и слишком длинным, можно в рамках определенной функции или файла использовать все имена из 
пространства имён без квалификатора, если написать инструкцию `using`:
```c++
void exibition()
{
    using namespace Zoo;
    
    Dog bobik;
    Wolf rex;
    Crocodile totosha;
}
```
В то же время мы получаем возможность различать одноименные объекты (или функции, или переменные, и т.д.)
```c++
namespace Forest{
    struct Wolf{};
    struct Rabbit{};
}
Zoo::Wolf meeting(Zoo::Wolf alpha, Forest::Wolf omega)
{
    return alpha + omega;
}
```
В данном случае типы структур волк из леса и волк из зоопарка разные, никак друг с другом не связанные (кроме 
одинакового имени).

Подключить сразу оба пространства имён целиком инструкцией `using` в случае наличия одинаковых идентификаторов 
не получится, чтобы не возникло путаницы.

Однако, можно подключить с `using` конкретные идентификаторы:
```c++
using Zoo::Wolf;
using Forrest::Rabbit;
```
Пространства имен открыты для добавлений новых идентификаторов. То есть если в одном месте уже встретилось описание 
нового namespace, это не значит, что в другом месте оно не может быть доопределено новыми идентфикаторами. Например, 
можно доопределить Forest:
```c++
namespace Forest{
    struct Fox{};
}
```
Пространства имён могут быть вложенными. Например,
```c++
namespace Zoo{
    namespace Aqua{
        struct Fish{};
        struct Jellyfish{};
    }
}
```
Пространства имён являются полушагом от модульной парадигмы к парадигме ООП.
